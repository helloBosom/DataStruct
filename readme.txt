参考了C++ Primer Plus第五版中文版 P8
C++实现                     源代码的扩展名
UNIX                       C、cc、cxx、c
GNU C++                    C、cc、cxx、cpp、c++
Borland C++                Cpp
Microsoft Visual C++       cpp、cxx、cc

数据结构:数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
    逻辑结构:对数据之间关系的描述
	    线性结构:数据元素的有序集合  有序表 一对一  如:集合
		非线性结构   一对多：树形，图形
	存储结构:物理结构  逻辑结构的映象    顺序、链式、索引、散列
	    数据元素的表示
		关系的表示
	对数据的运算

算法:基本运算及规定的运算顺序所构成的完整的解题步骤。
    1.有穷性
    2.确定性
    3.输入
    4.输出
    5.可行性
算法的设计目标:
    1.正确性
    2.可读性
    3.健壮性
    4.高效率和低存储量需求
时间复杂度:
空间复杂度:在运行时所需存储空间的度量，主要考算法运行过程中临时占用的存储空间大小

线性表:线性表是具有相同特性数据元素的一个有限序列。
    只有一个表头元素
	只有一格表尾元素
	表头元素没有前驱
	表尾元素没有后继
	除表头元素表尾元素，其他元素只有一个直接前驱，也只有一个直接后继
	
线性表:
    顺序存储结构：顺序表
        1.随机访问特性
        2.占用连续的存储空间。   存储空间只能预选分配。
      顺序表做插入操作的时候要移动多个元素 		
	链式存储结构:链表    结点不仅包含所存储元素信息，还包含元素之间逻辑关系的信息。
	    1.不支持随机访问
		2.结点的存储空间利用率较顺序表稍低一些。
		3.链表支持存储空间的动态分配
	  链表中进行插入操作无须移动元素
	  1.单链表
	      1.1带头结点的单链表，头指针head指向头结点，头结点的值域不含任何信息，从头结点的后继结点开始存储数据信息。头指针head始终不等于NULL，
		  head->next等于NULL的时候，链表为空。
		  1.2不带头结点的单链表，头指针head直接指向开始结点，head为NULL的时候，链表为空。
		  头指针始终指向链表中的第一个结点
	  2.双链表
	      带头结点的双链表，当head->next为NULL时链表为空
		  不带头结点的双链表，当head为空时链表为空
	  3.循环单链表:将单链表的最后一个指针域指向链表中的第一个结点
	      带头结点的循环单链表，当head等于head->next时，链表为空
		  不带头结点的循环单链表，当head等于NULL时，链表为空
	  4.循环双链表
	      带头结点的循环双链表中没有空指针。判断循环双链表是否为空，只需检查head->next和head->prior两个指针中的任意一个是否等于head指针。
		      四种判断：
			      head->next==head;
				  head->prior==head;
				  head->next==head&&head->prior==head;
				  head->next==head||head->prior==head;
	      当head等于NULL时，不带头结点的循环双链表为空
	  5.静态链表
	      一般链表结点空间来自于整个内存，静态链表来自于一个结构体数组。
		  数组中每一个结点含有两个分量:
		      数据元素分量data
			  指针分量   指示了当前结点的直接后继结点在数组中的位置
	
指针所需的存储空间是系统分配的

栈:栈是一种只能在一端进行插入或删除操作的线性表。
    栈顶:允许插入和删除操作的一端。        栈顶指针指示器
	栈底:
	入栈
	出栈
    特性:先进后出(FILO)
    顺序栈:
	    栈空状态
		栈满状态
		非法状态(上溢和下溢,栈满继续入栈和栈空继续出栈)
		进栈、出栈
    链式栈:
        栈空
		栈满
		进栈
		出栈
	   
队列:一种操作受限制的线性表。     
    队尾:可进行插入的一端。(Rear)
	队头:可进行删除的一端。(Front)
	进队:
	出队:
    特性:先进先出(FIFO)  

循环队列:
    必须损失一个存储空间用于区分队满和队空。
    队空:
　　　　qu.rear=qu.front　
    队满:
	　　(qu.rear+1)%maxSize=front　
　　入队:
        qu.rear=(qu.rear+1)%maxSize;
		qu.data[qu.rear]=x;
	出队:
	    qu.front=(qu.front+1)%maxSize;
	    x=qu.data[qu.front];
	    
链队:
    采用链式存储结构存储队列
　　特点:
　　　　不存在队满上溢的情况(内存溢出上溢另算)
　　队空:
        lqu->rear=NULL或lqu->front=NULL
	队满:
        内存足够大的情况下不存在队满
    进队:
        lqu->rear->next=p;
        lqu->rear=p;
    出队:
        p=lqu->front;
        lqu->front=p->next;
        x=p->data;
        free(p);

串:零个或多个字符组成的有限序列
    
宏:计算机科学里的宏（Macro)，是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）
如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。
中文名 宏 外文名 Macro

二维数组:矩阵

广义表:表元素可以是原子或者广义表的一种线性表的扩展结构。

二叉树:
    每个节点最多只有两颗子树
	子树有左右顺序之分，不能颠倒

满二叉树:
    所有的分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下一层。

二叉树性质:(待补充)
    1.非空二叉树上叶子结点数等于双分支结点数加1。
    2.二叉树的第i层上最多有2^i-1个结点。
    3.高度(或深度)为k的二叉树最多有2^k-1个结点。
    4.
    5.函数Catalan():给定n个结点，能构成h(n)种不同的二叉树，h(n)=C2n取n除以n+1;	
	6.具有n个结点的完全二叉树的高度为(log以2为底的n)加1 或log以2为底的(n+1)
	
二叉树遍历:
    1.先序遍历
        访问根结点
        先序遍历左子树
        先序遍历右子树
    2.中序遍历
        中序遍历左子树
        访问根结点
        中序遍历右子树
    3.后序遍历
        后序遍历左子树
        后续遍历右子树
        访问根结点

将树转化为二叉树:
    1.将同一结点的各孩子结点用线串起来。
	2.将每个结点的分支从左往右除第一个以外，其余都剪掉。
    3.调整结点使之符合二叉树的层次结构。
	
将二叉树转换为树:
    1.把树从左上到右下分为若干层。
    2.找到每一层结点在其上一层的父结点。
    3.将每一层的结点和其父结点相连，然后删除每一层结点之间的连接。

将森林转换为二叉树:
    1.先将森林中的树分别转化为二叉树。
	2.将第二颗二叉树作为第一颗二叉树根的右子树，将第三颗二叉树作为第二颗二叉树根的右子树。
	
二叉树转换为森林:
    不停地将根结点有右孩子的二叉树的右孩子链接断开，直到不存在根节点有右孩子的二叉树为止。然后将得到的多颗二叉树转化为树。

树转换成二叉树后，树的先序遍历对应二叉树的先序遍历，树的后序遍历对应二叉树的中序遍历。

huffman tree的构造方法:(给定n个权值)
    1.将这n个权值分别看作只有根节点的n颗二叉树，这些二叉树构成的集合记为F
    2.从F中选取两颗根结点的权值最小的树作为左右子树，构造一颗新的二叉树，新的二叉树的根结点的权值为左右子树根结点权值之和。
	3.从集合中删除已选取的树，加入新构造的树
	4.重复2、3，直至剩下一棵树
huffman tree特点：
	1.权值越大的结点，距离根结点越近
	2.树中没有度为1的结点。此类树又称作正则(严格)二叉树
	3.树的带权路径长度最短
huffman编码产生的是最短前缀码

树的带权路径(WPL)	

Map:
邻接矩阵:表示顶点之间相邻关系的矩阵。

AOV:Activity on Vertex network
AOE:Activity on Edge network
AOE网的边代表活动时间，顶点代表事件
AOV网的顶点表示活动，边无权值，边代表活动的先后顺序
事件是图中新活动开始或者旧活动结束的标志

排序算法的稳定性:
    当排序序列中有两个或两个以上相同关键字时，排序前和排序后这些关键字的相对顺序如果没有发生变化就是稳定的，否则就是不稳定的。
    关键字可以重复时，根据具体需求来考虑选择稳定还是不稳定的排序算法。关键字不重复时，排序结果唯一。
排序算法分类:
    1.插入类排序
    2.交换类排序
    3.选择类排序
    4.归并类排序
    5.基数类排序

希尔排序:(缩小增量排序)
    将待排序序列按某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。
	希尔排序增量选取:
	    1.增量序列的最后一个值一定取1。
		2.增量序列中的值应尽量没有除1之外的公因子。
	空间复杂度:O(1)	
	
冒泡排序结束条件:在一趟排序过程中没有发生关键字交换。

堆：一颗完全二叉树，满足任何一个非叶子结点的值都不大于(或不小于)其左右孩子结点的值。
    大顶堆：父亲大孩子小
    小顶堆：父亲小孩子大	
堆排序中最关键的操作是将序列调整为堆。

散列表:
    hash表:根据给定的关键字依照函数来计算关键字key在表中的地址，并把key存在这个地址上。
    常用hash函数构造方法:
        (1)直接定址法
        (2)数字分析法
        (3)平方取中法
        (4)除留余数法		
	常用hash冲突处理方法:
        (1)开放定址法
        (2)链地址法		